#show raw.where(block: true): it => {
    set text( size: 7pt)
    set align(left)
    set block(fill: luma(240), inset: 10pt, radius: 4pt, width: 100%)
    it
}
#show raw.where(block: false): box.with(
  fill: luma(240),
  inset: (x: 3pt, y: 0pt),
  outset: (y: 3pt),
  radius: 2pt
)
#set page(numbering: "1/1")



= Additional documentation on the implementation of kernels under the RacEr architecture
This work is an addition to the documentation based on the RacEr architecture developed by Vividspark from a Manycore architecture. 


= API RacEr

#table(columns: (50%, 50%), fill : (x,y) => (if (y==0) {rgb("#DEDEDE")}), 
[#align(center)[RacEr Kernel Function]],[#align(center)[Definition]],
[```c
 RacEr_set_tile_x_y()```],[ Sets RacEr_X and RacEr_Y to the X and Y coordinate of the tile.],
[```c
 RacEr_x_y_to_id(int x, int y)```],[ Calculates tile’s flat id using its (x,y) coordinates.],
[```c
 RacEr_id_to_x(int x)```],[ Calculates tile’s x coordinate using its flat id.], 
[```c
 RacEr_id_to_y(int y)```],[ Calculates tile’s y coordinate using its flat id.], 
[```c
 RacEr_remote_ptr (int x, int y, void *addr)```],[Forms a remote address by taking in x and y coordinates of remote tile and the address to local variable. Used in RacEr_remote_store and RacEr_remote_load.], 
[```c
 RacEr_remote_store (int x, int y, void *addr, int val)```],[ Stores val to the local address addr in the memory space of the tile at (x,y)], 
[```c
 RacEr_remote_store_uint8 (int x, int y, void *addr, unsigned char val)```],[Stores the 1-byte val to the local address addr in the memory space of the tile at (x,y)],
[```c
 RacEr_remote_store_uint16 (int x, int y, void *addr, unsigned short val)```],[Stores the 2-byte val to the local address addr in the memory space of the tile at (x,y)],
[```c
 RacEr_remote_load (int x, int y, void *addr)```],[ Loads from the local address addr in the memory space of the tile at (x,y)],
[```c
 RacEr_dram_ptr (void *addr)```],[Forms a pointer to an element on the DRAM attached to the bottom of tile’s column using the local address.],
[```c
 RacEr_dram_load (void *addr, val)```],[ Loads from DRAM into val by using RacEr_dram_ptr.],
[```c
 RacEr_dram_store (void *addr, val)```],[ Stores val into dram by using RacEr_dram_ptr.],
[```c
 RacEr_tilegroup_ptr (void *addr, int index)```],[ Takes in the local address of tilegroup-shared memory, and the array index. Calculates the coordinates of the tile holding that index, and returns a RacEr_remote_ptr to that element.],
[```c
 RacEr_tilegroup_load (void *addr, int index, val)```],[ Loads from tilegroup-shared memory into val by taking in its local address and index, using RacEr_tilegroup_ptr.],
[```c
 RacEr_tilegroup_store (void *addr, int index)```],[ Stores local val to tilegroup-shared memory by taking in its local address and index, using RacEr_tilegroup_ptr.],
[```c
 RacEr_remote_control_store (int x, int y, void *addr, val)```],[ Remote stores the value into the instruction memory of tile (x,y) using local address.],
[```c
 RacEr_remote_freeze (int x, int y)```],[ Starts the execution of tile (x,y) using RacEr_remote_control_store.],
[```c
 RacEr_remote_unfreeze (int x, int y)```],[ Stops the execution of tile (x,y) using RacEr_remote_control_store.],
[```c
 INIT_TILE_GROUP_BARRIER (ROW_BARRIER_NAME, COL_BARRIER_NAME, int x_cord_start, int x_cord_end, int y_cord_start, int y_cord_end)```],[Initializes parameters for a barrier instruction for all tiles within tilegroup using the start and end coordinates of the tilegroup.],
[```c
 RacEr_tile_group_barrier (ROW_BARRIER_NAME, COL_BARRIER_NAME)```],[Synchronizes all tiles within the tilegroup by taking in the row and column barrier names generated by `INIT_TILE_GROUP_BARRIER`.],
[```c
 RacEr_wait_while(int cond)```],[Wait for condition to be true],
[```c
 poll_range(int range, unsigned char *ptr_value)```],[Check if no 0 value in `ptr_value`],
[```c
 RacEr_print_float(posit f)```],[Print posit value],
)

#pagebreak()
#table(columns: (50%, 50%), fill : (x,y) => (if (y==0) {rgb("#DEDEDE")}), 
[#align(center)[RacEr main function]],[#align(center)[Definition]],
[```c
 RacEr_mc_device_malloc (RacEr_mc_device_t *device, int size, void *src)```],[allocate memory `size` on targeted `device` accessible with the `src` ],
[```c
 RacEr_mc_device_memcpy (RacEr_mc_device_t *device, void *dst, void *src, int size, hb_mc_memcpy_kind kind)```],[Copy memory `size` from `src` to `dst` on the `device`. You must specify how : `HB_MC_MEMCPY_TO_DEVICE` or `HB_MC_MEMCPY_TO_HOST`],
[```c
 RacEr_mc_device_memset (RacEr_mc_device_t *device, void *src, int value, int size)```],[Set memory `size` for the `src` to `value` on the `device`],
[```c
 RacEr_printf (format, ...)```],[print ],
[```c
 RacEr_mc_kernel_enqueue (RacEr_mc_device_t *device, RacEr_mc_dimension_t grid_dim, RacEr_mc_dimension_t tg_dim, char *function_name, int function_argc, int *function_argv)```],[Enqueue function with a `function_name` on `device`. Specify how the `grid_dim` and `tg_dim`. Pass the function parameter throw `function_argc` and `function_argv` in a ```c
 int kernel_args[] = {function_arg, ...}```],
[```c
 RacEr_mc_device_tile_groups_execute (RacEr_mc_device_t *device) ```],[Execute the function enqueue on the `device`],
[```c
 RacEr_mc_device_init (RacEr_mc_device_t *device, char *name, int device_id)```],[initialise the `device` with the `name` on a specific `device_id`],
[```c
 RacEr_mc_device_program_init (RacEr_mc_device_t *device, char *bin_path, char *allocator, int device_id)```],[initialise the program on the `device` with the `bin_path` program. It requires an `allocator` and the `device_id`],
[```c
 argp_parse (&argp_path, int argc, char *argv, 0, 0, struct arguments_path *args)```],[Function to parse args from Command line and store it in `args` which is an `arguments_path` type],
[```c
 RacEr_mc_device_finish (RacEr_mc_device_t *device)```],[Terminate the simulation on the `device`],
[```c
 RacEr_mc_device_free(RacEr_mc_device_t *device, void *src)```],[free allocated memory on `device`],
)
#pagebreak()
#table(columns: (50%, 50%), fill : (x,y) => (if (y==0) {rgb("#DEDEDE")}), 
[#align(center)[RacEr Macro]],[#align(center)[Definition]],
[```c
RacEr_mc_dimension_t tg_dim = { .x = x, .y = y }
RacEr_mc_dimension_t grid_dim = { .x = value / block_size_x, .y = value / block_size_y }```],[2-dimension type for `tg_dim` and `grid_dim`],
[```c
#define ALLOC_NAME "default_allocator"```],[Definition of the `default_allocator`],
[```c
#define HB_MC_SUCCESS       (0)
#define HB_MC_FAIL          (-1)
#define HB_MC_TIMEOUT       (-2)
#define HB_MC_UNINITIALIZED (-3)
#define HB_MC_INVALID       (-4)
#define HB_MC_INITIALIZED_TWICE (-4) // same as invalid
#define HB_MC_NOMEM         (-5)
#define HB_MC_NOIMPL        (-6)
#define HB_MC_NOTFOUND      (-7)
#define HB_MC_BUSY          (-8)
#define HB_MC_UNALIGNED     (-9)```],[Errno macro],
[```c
 enum hb_mc_memcpy_kind { HB_MC_MEMCPY_TO_DEVICE, HB_MC_MEMCPY_TO_HOST }```],[],
[```c
 RacEr_mc_device_t device```],[Device type],
[```c
 struct arguments_path args = {name, path}```],[Struct to store function `name` and `path`],
[```c
 #define RacEr_TILE_GROUP_X_DIM RacEr_tiles_X
int start_x = __RacEr_tile_group_id_x * block_size_x
int end_x = start_x + block_size_x ```],[Get a thread action field],
)



#pagebreak()
== Migration of Cuda code to RacEr

=== SGEMM Kernel example (Single precision matrix matrix multiply)

*RacEr*
```c
#include "RacEr_manycore.h"
#include "RacEr_set_tile_x_y.h"

// define and init barrier
#include "RacEr_tile_group_barrier.h"
INIT_TILE_GROUP_BARRIER (r_barrier, c_barrier, 0, RacEr_tiles_X - 1, 0,
                         RacEr_tiles_Y - 1);

// define tiles X & Y
#define RacEr_TILE_GROUP_X_DIM RacEr_tiles_X
#define RacEr_TILE_GROUP_Y_DIM RacEr_tiles_Y

int __attribute__ ((noinline))
kernel_float_matrix_mul (float *A, float *B, float *C, int N,
                         int block_size_y, int block_size_x)
{


  int start_y = __RacEr_tile_group_id_y * block_size_y;
  int start_x = __RacEr_tile_group_id_x * block_size_x;
  int end_y = start_y + block_size_y;
  int end_x = start_x + block_size_x;

  for (int iter_y = start_y + __RacEr_y; iter_y < end_y;
       iter_y += RacEr_tiles_Y)
    {
      for (int iter_x = start_x + __RacEr_x; iter_x < end_x;
           iter_x += RacEr_tiles_X)
        {
          float sum = 0;
          for (int k = 0; k < N; k++)
            {
              A_const = A[iter_y * N + k];
              B_const = B[k * N + iter_x];
              sum += A[iter_y * N + k] * B[k * N + iter_x];
            }
          C[iter_y * N + iter_x] = sum;
        }
    }
  // Synchronize tile before end
  RacEr_tile_group_barrier (&r_barrier, &c_barrier);
  return 0;
}
```

  *Cuda*
```c
__global__ void
sgemm (double *A, double *B, double *C, int N)
{
  int i = blockIdx.x * blockDim.x + threadIdx.x;
  int j = blockIdx.y * blockDim.y + threadIdx.y;
  double sum = 0.;
  for (int k = 0; k < N; k++)
    {
      sum += A[i * N + k] * B[k * N + j];
    }
  C[i * N + j] = sum;
}
  ```


== Measuring
Use time.h library
```c

#define get_sub_seconde(t) (1e-9 * (double)t.tv_nsec)
// clock_gettime function
double
get_elapsedtime (void)
{
  struct timespec st;
  int err =  clock_gettime (CLOCK_MONOTONIC_RAW, &st);
  if (err != 0)
    return 0;
  return (double)st.tv_sec + get_sub_seconde (st);
}

double init_time, end_time;
init_time = get_elapsedtime();
kernel();
end_time =  get_elapsedtime();
```

